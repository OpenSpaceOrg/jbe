// Generated by delombok at Mon Aug 07 15:45:02 CEST 2023
package com.github.openspaceapp.jbe.domain.mapper;

import com.github.openspaceapp.jbe.application.exception.MissingHeaderException;
import com.github.openspaceapp.jbe.domain.model.KonopasPerson;
import com.github.openspaceapp.jbe.domain.model.KonopasSession;
import com.github.openspaceapp.jbe.infrastructure.client.model.SheetImport;
import com.github.openspaceapp.jbe.infrastructure.client.model.SheetRow;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class SheetMapperImpl implements SheetMapper {
    @SuppressWarnings("all")
    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(SheetMapperImpl.class);
    private final List<String> requiredHeaders = Lists.newArrayList("id", "title", "date", "time");

    @Override
    public List<KonopasSession> map(SheetImport sheetImport) {
        Headers headers = new Headers(sheetImport.getHeaders());
        requiredHeaders.forEach(requiredHeader -> throwIfHeaderMissing(headers, requiredHeader));
        return sheetImport.getRows().stream().map(Row::new).map(row -> row.withHeaders(headers)).map(this::createSession).filter(this::isSessionValid).collect(Collectors.toList());
    }

    private boolean isSessionValid(KonopasSession session) {
        if (session == null || session.getTime() == null) {
            log.warn("session or session time is null session={}", session);
            return false;
        }
        if (session.getTime().equals("/")) {
            log.info("session name={}, id={} is marked invalid by time=/", session.getTitle(), session.getId());
            return false;
        }
        return true;
    }

    private KonopasSession createSession(Row row) {
        return KonopasSession.builder().id(row.get("id")).title(row.get("title")).desc(row.get("desc")).date(row.get("date")).time(row.get("time")).mins(row.get("mins")).loc(createLocation(row)).tags(createTags(row)).people(createPeople(row)).build();
    }

    private List<String> createLocation(Row row) {
        return Collections.singletonList(row.get("loc.0"));
    }

    private List<String> createTags(Row row) {
        return Lists.newArrayList(row.get("tags.0"), row.get("tags.1"), row.get("tags.2"));
    }

    private List<KonopasPerson> createPeople(Row row) {
        return IntStream.rangeClosed(0, 4).mapToObj(index -> getPersonForIndex(index, row)).filter(Objects::nonNull).collect(Collectors.toList());
    }

    private KonopasPerson getPersonForIndex(int index, Row row) {
        return KonopasPerson.of(row.get("people." + index + ".id"), row.get("people." + index + ".name"));
    }

    private void throwIfHeaderMissing(Headers headers, String x) {
        if (!headers.containsKey(x)) {
            throw new MissingHeaderException("Header " + x + " is missing");
        }
    }
}

class Headers {
    private Map<String, Integer> headers = Maps.newHashMap();

    Headers(List<String> headerList) {
        int i = 0;
        for (String header : headerList) {
            headers.put(header, i++);
        }
    }

    Integer get(String key) {
        return headers.get(key);
    }

    boolean containsKey(String key) {
        return headers.containsKey(key);
    }
}

class Row {
    private final SheetRow sheetRow;
    private Headers headers;

    String get(String key) {
        return sheetRow.get(headers.get(key));
    }

    @SuppressWarnings("all")
    public Row(final SheetRow sheetRow) {
        this.sheetRow = sheetRow;
    }

    @SuppressWarnings("all")
    private Row(final SheetRow sheetRow, final Headers headers) {
        this.sheetRow = sheetRow;
        this.headers = headers;
    }

    /**
     * @return a clone of this object, except with this updated property (returns {@code this} if an identical value is passed).
     */
    @SuppressWarnings("all")
    public Row withHeaders(final Headers headers) {
        return this.headers == headers ? this : new Row(this.sheetRow, headers);
    }
}
